<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>P2HD Web Bluetooth æ–°æ‰‹ç‰ˆï¼ˆå®Œæ•´ç¯„ä¾‹ï¼‰</title>
  <style>
    body { font-family: system-ui, -apple-system, "Noto Sans TC", Arial; margin: 0; padding: 16px; line-height: 1.5; }
    h1 { font-size: 18px; margin: 0 0 8px; }
    .row { margin: 10px 0; display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    button, input[type="file"] { font-size: 15px; }
    button { padding: 10px 14px; border-radius: 12px; border: 1px solid #cfcfcf; background: #fff; }
    button:disabled { opacity: 0.5; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; border: 1px solid #ddd; font-size: 12px; }
    .ok { color: #0a7; border-color: #0a7; }
    .bad { color: #c22; border-color: #c22; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #log { white-space: pre-wrap; background: #f6f6f6; padding: 12px; border-radius: 12px; height: 260px; overflow: auto; }
    #preview { max-width: 100%; border: 1px dashed #aaa; border-radius: 12px; margin-top: 8px; }
    label { font-size: 14px; }
    textarea { width: 100%; min-height: 76px; border-radius: 12px; border: 1px solid #ddd; padding: 10px; font-size: 14px; }
    .small { font-size: 12px; color: #555; }
    .warn { background: #fff3cd; border: 1px solid #ffeeba; padding: 10px; border-radius: 12px; }
    .info { background: #eef6ff; border: 1px solid #cfe6ff; padding: 10px; border-radius: 12px; }
  </style>
</head>
<body>
  <h1>P2HD Web Bluetooth æ–°æ‰‹ç‰ˆï¼ˆå®Œæ•´ HTMLï¼‰</h1>

  <div class="info small">
    å¿…è¦æ¢ä»¶ï¼š<b>Android + Chrome/Edge</b>ã€ä¸”é é¢å¿…é ˆæ˜¯ <b>HTTPS</b>ï¼ˆNetlify/GitHub Pagesï¼‰ã€‚<br/>
    iPhone / iOS Safari ä¸æ”¯æ´ Web Bluetoothï¼Œå› æ­¤æœƒé¡¯ç¤ºã€Œä¸æ”¯æ´ã€æç¤ºã€‚
  </div>

  <div class="row">
    <span id="badgeSecure" class="pill mono">Secure: ?</span>
    <span id="badgeBT" class="pill mono">WebBluetooth: ?</span>
    <span id="badgeOS" class="pill mono">OS: ?</span>
  </div>

  <div class="row">
    <button id="btnDiag">0) ç’°å¢ƒæª¢æŸ¥ï¼ˆä¸€å®šè¦å…ˆæŒ‰ï¼‰</button>
    <button id="btnConnect">1) Connect Printerï¼ˆæƒæ/é…å°ï¼‰</button>
    <button id="btnDiscover" disabled>2) åˆ—å‡º Services/Characteristics</button>
    <button id="btnPickWritable" disabled>3) è‡ªå‹•é¸ Writable Characteristic</button>
  </div>

  <div class="row">
    <button id="btnWriteHello" disabled>4) å¯«å…¥æ¸¬è©¦ï¼ˆHELLOï¼‰</button>
    <button id="btnNotifyOn" disabled>5) é–‹å•Ÿ Notifyï¼ˆè‹¥æœ‰ï¼‰</button>
    <span class="small mono" id="chosenInfo"></span>
  </div>

  <div class="row">
    <label class="small">è©©å¥ï¼ˆå…ˆç”¨å‡è³‡æ–™æˆ–æ‰‹å‹•è²¼ä¸Šï¼›ä½ ä¹‹å¾Œå†æ¥ AIï¼‰ï¼š</label>
  </div>
  <textarea id="poem" placeholder="ä¾‹ï¼š\næˆ‘æŠŠå…‰æ‘ºæˆä¸€å¼µå°ç´™\nå¡é€²å£è¢‹è£¡\nåœ¨ä½ èµ°éçš„è·¯ä¸Š\nå®ƒæ…¢æ…¢ç™¼ç†±\n"></textarea>

  <div class="row">
    <input id="file" type="file" accept="image/*" capture="environment" disabled />
    <button id="btnCompose" disabled>6) åˆæˆã€Œåœ–ç‰‡+è©©ã€åˆ° Canvas</button>
    <button id="btnSendBitmap" disabled>7) é€å‡ºä½åœ–è³‡æ–™ï¼ˆä¸ä¿è­‰å°å‡ºï¼‰</button>
  </div>

  <canvas id="preview" width="384" height="10"></canvas>

  <div class="row">
    <label class="small">Logï¼ˆè«‹æŠŠé€™è£¡çš„å…§å®¹è²¼å›ä¾†ï¼Œæ‰èƒ½ç²¾æº–å°æ¥ P2HD å”å®šï¼‰ï¼š</label>
  </div>
  <pre id="log" class="mono"></pre>

<script>
/** ========= åŸºç¤å·¥å…· ========= **/
const logEl = document.getElementById('log');
function log(...args) {
  const s = args.map(a => (typeof a === 'string' ? a : JSON.stringify(a, null, 2))).join(' ');
  logEl.textContent += s + '\n';
  logEl.scrollTop = logEl.scrollHeight;
}
function toHex(u8) {
  return Array.from(u8).map(x => x.toString(16).padStart(2, '0')).join(' ');
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function isIOS() {
  const ua = navigator.userAgent || '';
  return /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
}
function osLabel() {
  if (isIOS()) return 'iOS';
  const ua = navigator.userAgent || '';
  if (/Android/i.test(ua)) return 'Android';
  if (/Windows/i.test(ua)) return 'Windows';
  if (/Mac/i.test(ua)) return 'Mac';
  return 'Unknown';
}

/** ========= ç‹€æ…‹ ========= **/
let device = null;
let server = null;
let services = [];
let allChars = []; // { serviceUuid, char, props }
let writeChar = null;
let notifyChar = null;

// é€™æ˜¯ Paperang/å–µå–µæ©Ÿç³»å¸¸è¦‹ Transparent UART æœå‹™ UUIDï¼ˆå¾ˆå¤šæ©Ÿå‹æœƒç”¨ï¼Œä½†ä¸ä¿è­‰ï¼‰
// æˆ‘å€‘æƒæéšæ®µä¸ç”¨ filtersï¼Œé¿å…æƒä¸åˆ°ï¼›é€£ç·šå¾Œå†æ‰¾é€™å€‹ serviceã€‚
const COMMON_SERVICE_UUID = '49535343-fe7d-4ae5-8fa9-9fafd205e455';

const badgeSecure = document.getElementById('badgeSecure');
const badgeBT = document.getElementById('badgeBT');
const badgeOS = document.getElementById('badgeOS');
const chosenInfo = document.getElementById('chosenInfo');

function setBadge(el, ok, text) {
  el.textContent = text;
  el.classList.remove('ok', 'bad');
  el.classList.add(ok ? 'ok' : 'bad');
}

/** ========= 0) ç’°å¢ƒæª¢æŸ¥ ========= **/
document.getElementById('btnDiag').addEventListener('click', () => {
  alert('DIAG: click event works.');

  const secure = window.isSecureContext;
  setBadge(badgeSecure, secure, 'Secure: ' + secure);

  const btSupported = !!navigator.bluetooth;
  setBadge(badgeBT, btSupported, 'WebBluetooth: ' + btSupported);

  const os = osLabel();
  setBadge(badgeOS, os !== 'Unknown', 'OS: ' + os);

  log('--- DIAG ---');
  log('isSecureContext:', secure);
  log('navigator.bluetooth exists:', btSupported);
  log('UserAgent:', navigator.userAgent);

  if (isIOS()) {
    log('âš ï¸ ä½ ç›®å‰çœ‹èµ·ä¾†æ˜¯ iOSã€‚iOS Safari ä¸æ”¯æ´ Web Bluetoothï¼›è‹¥è¦é€£ P2HDï¼Œéœ€æ”¹ç”¨åŸç”Ÿ Appï¼ˆReact Native/Flutter/Swiftï¼‰ã€‚');
    alert('ä½ æ˜¯ iOSï¼šSafari ä¸æ”¯æ´ Web Bluetoothã€‚è‹¥ä½ è¦ç”¨ç¶²é é€£è—ç‰™ï¼Œè«‹æ”¹ Android Chromeã€‚');
  }

  if (!secure) {
    log('âŒ é Secure Contextï¼šè«‹ç”¨ https:// ç¶²å€ï¼ˆNetlify/GitHub Pagesï¼‰æˆ– localhostã€‚');
    alert('Web Bluetooth éœ€è¦ HTTPSï¼ˆæˆ– localhostï¼‰ã€‚è«‹ç”¨ Netlify/GitHub Pages çš„ https ç¶²å€é–‹å•Ÿã€‚');
  }

  if (!btSupported) {
    log('âŒ ç€è¦½å™¨ä¸æ”¯æ´ Web Bluetoothï¼šè«‹ç”¨ Android çš„ Chrome/Edgeã€‚');
    alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´ Web Bluetoothã€‚è«‹æ”¹ç”¨ Android Chrome/Edgeã€‚');
  }
});

/** ========= 1) Connect Printer ========= **/
document.getElementById('btnConnect').addEventListener('click', async () => {
  alert('CONNECT: click received.'); // ç¢ºèªæŒ‰éˆ•çœŸçš„æœ‰è§¸ç™¼

  try {
    if (!window.isSecureContext) throw new Error('Not a secure context. Please use HTTPS.');
    if (!navigator.bluetooth) throw new Error('Web Bluetooth not supported in this browser.');
    if (isIOS()) throw new Error('iOS Safari does not support Web Bluetooth.');

    log('--- CONNECT ---');
    log('Requesting device (acceptAllDevices: true)...');

    // é—œéµï¼šå…ˆç”¨ acceptAllDevicesï¼Œé¿å… service filter æƒä¸åˆ°è£ç½®
    device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      // optionalServicesï¼šè®“å¾ŒçºŒ getPrimaryService æ™‚æœ‰æ©Ÿæœƒæ‹¿åˆ°æ›´å¤šæœå‹™è³‡è¨Š
      optionalServices: [COMMON_SERVICE_UUID, 'battery_service']
    });

    log('Selected device name:', device.name || '(no name)');
    log('Connecting GATT...');
    server = await device.gatt.connect();
    log('âœ… GATT connected.');

    document.getElementById('btnDiscover').disabled = false;
    document.getElementById('file').disabled = false;
    document.getElementById('btnCompose').disabled = false;

    alert('å·²é€£ç·šæˆåŠŸï¼ˆGATT connectedï¼‰ã€‚ä¸‹ä¸€æ­¥è«‹æŒ‰ã€Œåˆ—å‡º Services/Characteristicsã€ã€‚');

  } catch (e) {
    log('âŒ CONNECT error:', e.message);
    alert('Connect å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= 2) åˆ—å‡º Services/Characteristics ========= **/
document.getElementById('btnDiscover').addEventListener('click', async () => {
  try {
    if (!server) throw new Error('No GATT server. Please connect first.');

    log('--- DISCOVER ---');
    services = await server.getPrimaryServices();
    log('Primary services count:', services.length);

    allChars = [];
    for (const svc of services) {
      const chars = await svc.getCharacteristics();
      log('Service:', svc.uuid, 'chars:', chars.length);

      for (const ch of chars) {
        const p = ch.properties;
        const flags = [];
        if (p.read) flags.push('read');
        if (p.write) flags.push('write');
        if (p.writeWithoutResponse) flags.push('writeWithoutResponse');
        if (p.notify) flags.push('notify');
        if (p.indicate) flags.push('indicate');

        log('  - Char:', ch.uuid, '[' + flags.join(',') + ']');

        allChars.push({ serviceUuid: svc.uuid, char: ch, props: p });
      }
    }

    document.getElementById('btnPickWritable').disabled = false;
    alert('å·²åˆ—å‡ºæ‰€æœ‰ Services/Characteristicsã€‚ä¸‹ä¸€æ­¥æŒ‰ã€Œè‡ªå‹•é¸ Writableã€ã€‚');

  } catch (e) {
    log('âŒ DISCOVER error:', e.message);
    alert('Discover å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= 3) è‡ªå‹•é¸ Writable + Notify ========= **/
document.getElementById('btnPickWritable').addEventListener('click', async () => {
  try {
    if (!allChars.length) throw new Error('No characteristics discovered.');

    log('--- PICK WRITABLE ---');

    // å„ªå…ˆï¼šåœ¨ COMMON_SERVICE_UUID æœå‹™ä¸‹æ‰¾å¯å¯«
    const inCommonSvc = allChars.filter(x => x.serviceUuid === COMMON_SERVICE_UUID);

    function pickWrite(list) {
      // å…ˆæŒ‘ writeWithoutResponseï¼ˆé€šå¸¸åˆ—å°æµé‡å¤§æ¯”è¼ƒå¥½ï¼‰
      let w = list.find(x => x.props.writeWithoutResponse);
      if (!w) w = list.find(x => x.props.write);
      return w ? w.char : null;
    }
    function pickNotify(list) {
      const n = list.find(x => x.props.notify);
      return n ? n.char : null;
    }

    writeChar = pickWrite(inCommonSvc) || pickWrite(allChars);
    notifyChar = pickNotify(inCommonSvc) || pickNotify(allChars);

    if (!writeChar) throw new Error('æ‰¾ä¸åˆ°å¯å¯«å…¥çš„ characteristicï¼ˆwrite/writeWithoutResponseï¼‰ã€‚');

    chosenInfo.textContent =
      `write: ${writeChar.uuid}  |  notify: ${notifyChar ? notifyChar.uuid : '(none)'}`;

    log('âœ… Selected writeChar:', writeChar.uuid);
    if (notifyChar) log('âœ… Selected notifyChar:', notifyChar.uuid);
    else log('âš ï¸ No notify characteristic found (ok).');

    document.getElementById('btnWriteHello').disabled = false;
    document.getElementById('btnSendBitmap').disabled = false;
    document.getElementById('btnNotifyOn').disabled = !notifyChar;

    alert('å·²é¸å®šå¯å¯«å…¥çš„ characteristicã€‚å¯å…ˆæŒ‰ã€Œå¯«å…¥ HELLOã€æ¸¬è©¦ã€‚');

  } catch (e) {
    log('âŒ PICK error:', e.message);
    alert('Pick Writable å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= 4) å¯«å…¥æ¸¬è©¦ï¼ˆHELLOï¼‰ ========= **/
document.getElementById('btnWriteHello').addEventListener('click', async () => {
  try {
    if (!writeChar) throw new Error('No writeChar selected.');
    log('--- WRITE HELLO ---');
    const data = new TextEncoder().encode('HELLO');
    // å…ˆç”¨ writeValueWithoutResponseï¼ˆè‹¥ä¸æ”¯æ´æœƒä¸ŸéŒ¯èª¤ï¼Œæ”¹ç”¨ writeValueï¼‰
    if (writeChar.properties.writeWithoutResponse) {
      await writeChar.writeValueWithoutResponse(data);
    } else {
      await writeChar.writeValue(data);
    }
    log('âœ… Wrote bytes:', toHex(data));
    alert('å·²å¯«å…¥ HELLOï¼ˆä¸ä»£è¡¨æœƒå°å‡ºï¼Œä½†ä»£è¡¨é€šé“å¯å¯«ï¼‰ã€‚');
  } catch (e) {
    log('âŒ WRITE HELLO error:', e.message);
    alert('å¯«å…¥å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= 5) é–‹å•Ÿ Notify ========= **/
document.getElementById('btnNotifyOn').addEventListener('click', async () => {
  try {
    if (!notifyChar) throw new Error('No notifyChar.');
    log('--- NOTIFY ON ---');
    await notifyChar.startNotifications();
    notifyChar.addEventListener('characteristicvaluechanged', (ev) => {
      const v = new Uint8Array(ev.target.value.buffer);
      log('ğŸ”” Notify:', toHex(v));
    });
    log('âœ… Notifications started.');
    alert('Notify å·²é–‹å•Ÿã€‚è‹¥å°è¡¨æ©Ÿæœ‰å›æ‡‰ï¼Œlog æœƒé¡¯ç¤ºã€‚');
  } catch (e) {
    log('âŒ NOTIFY error:', e.message);
    alert('Notify å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= åˆæˆã€Œåœ–ç‰‡ + è©©ã€åˆ° Canvas ========= **/
const fileInput = document.getElementById('file');
const poemInput = document.getElementById('poem');
const preview = document.getElementById('preview');
const pctx = preview.getContext('2d', { willReadFrequently: true });

let composedImageData = null; // ImageDataï¼ˆRGBAï¼‰
let composedW = 384, composedH = 0;

document.getElementById('btnCompose').addEventListener('click', async () => {
  try {
    const f = fileInput.files && fileInput.files[0];
    if (!f) throw new Error('è«‹å…ˆé¸ä¸€å¼µç…§ç‰‡ã€‚');

    const bmp = await createImageBitmap(f);
    const targetW = 384;
    const scale = targetW / bmp.width;
    const imgH = Math.max(1, Math.round(bmp.height * scale));

    // è©©å€é«˜åº¦ä¼°ç®—ï¼šæ¯è¡Œ 22pxï¼Œæœ€å¤š 12 è¡Œï¼Œå¤–åŠ  padding
    const poemLines = (poemInput.value || '').trim().split('\n').filter(Boolean);
    const lines = poemLines.length ? poemLines : ['ï¼ˆé€™è£¡æœƒå°å‡ºä½ çš„æ–°è©©ï¼‰'];
    const maxLines = Math.min(lines.length, 12);
    const poemH = 24 * (maxLines + 2);

    composedW = targetW;
    composedH = imgH + poemH;

    preview.width = composedW;
    preview.height = composedH;

    // èƒŒæ™¯ç™½
    pctx.fillStyle = '#fff';
    pctx.fillRect(0, 0, composedW, composedH);

    // åœ–ç‰‡
    pctx.drawImage(bmp, 0, 0, composedW, imgH);

    // è©©æ–‡å­—ï¼ˆå…ˆç”¨é»‘å­—ç•«ï¼›å¾Œé¢æœƒäºŒå€¼åŒ–ï¼‰
    pctx.fillStyle = '#000';
    pctx.font = '18px system-ui, -apple-system, "Noto Sans TC", Arial';
    pctx.textBaseline = 'top';

    const leftPad = 12;
    let y = imgH + 12;
    for (let i = 0; i < maxLines; i++) {
      pctx.fillText(lines[i], leftPad, y);
      y += 24;
    }

    composedImageData = pctx.getImageData(0, 0, composedW, composedH);
    log('--- COMPOSE ---');
    log(`âœ… Canvas composed: ${composedW}x${composedH}, poem lines: ${maxLines}`);
    alert('å·²åˆæˆåˆ° Canvasã€‚ä¸‹ä¸€æ­¥å¯æŒ‰ã€Œé€å‡ºä½åœ–è³‡æ–™ã€ã€‚');
  } catch (e) {
    log('âŒ COMPOSE error:', e.message);
    alert('Compose å¤±æ•—ï¼š' + e.message);
  }
});

/** ========= å½±åƒ â†’ 1-bit ä½åœ–æ‰“åŒ…ï¼ˆ384 å¯¬ï¼‰ ========= **/
function imageDataTo1BitPacked(imgData, threshold = 160) {
  const { data, width, height } = imgData;

  // è½‰ç°éš + äºŒå€¼åŒ–ï¼ˆç°¡æ˜“é–€æª»ï¼›ä¹‹å¾Œå¯å‡ç´š Floydâ€“Steinberg æŠ–å‹•ï¼‰
  const mono = new Uint8Array(width * height); // 1=é»‘ 0=ç™½
  for (let i = 0; i < width * height; i++) {
    const r = data[i * 4 + 0];
    const g = data[i * 4 + 1];
    const b = data[i * 4 + 2];
    // å¿½ç•¥ alpha
    const y = (0.299 * r + 0.587 * g + 0.114 * b);
    mono[i] = (y < threshold) ? 1 : 0;
  }

  // æ¯ 8 åƒç´ æ‰“åŒ…æˆ 1 byteï¼ˆMSBâ†’LSBï¼‰
  const bytesPerRow = Math.ceil(width / 8);
  const packed = new Uint8Array(bytesPerRow * height);
  for (let y = 0; y < height; y++) {
    for (let bx = 0; bx < bytesPerRow; bx++) {
      let v = 0;
      for (let bit = 0; bit < 8; bit++) {
        const x = bx * 8 + bit;
        const pixel = (x < width) ? mono[y * width + x] : 0;
        v = (v << 1) | (pixel & 1);
      }
      packed[y * bytesPerRow + bx] = v;
    }
  }
  return { width, height, bytesPerRow, packed };
}

/** ========= åˆ†åŒ…å¯«å…¥ ========= **/
function chunkArray(u8, size) {
  const chunks = [];
  for (let i = 0; i < u8.length; i += size) {
    chunks.push(u8.subarray(i, Math.min(i + size, u8.length)));
  }
  return chunks;
}
async function writeChunks(chunks, gapMs = 10) {
  for (const c of chunks) {
    if (writeChar.properties.writeWithoutResponse) {
      await writeChar.writeValueWithoutResponse(c);
    } else {
      await writeChar.writeValue(c);
    }
    if (gapMs) await sleep(gapMs);
  }
}

/** ========= 7) é€å‡ºä½åœ–è³‡æ–™ï¼ˆæ³¨æ„ï¼šä¸ä¸€å®šæœƒå°å‡ºï¼Œå› ç‚º P2HD å¯èƒ½éœ€è¦ç‰¹å®šå”è­°å°åŒ…ï¼‰ ========= **/
document.getElementById('btnSendBitmap').addEventListener('click', async () => {
  try {
    if (!writeChar) throw new Error('è«‹å…ˆ Connect ä¸¦é¸å®š writable characteristicã€‚');
    if (!composedImageData) throw new Error('è«‹å…ˆæŒ‰ã€Œåˆæˆåœ–ç‰‡+è©©ã€åˆ° Canvasã€‚');

    log('--- SEND BITMAP (RAW STREAM) ---');
    const bm = imageDataTo1BitPacked(composedImageData, 160);
    log(`Bitmap packed: ${bm.width}x${bm.height}, bytesPerRow=${bm.bytesPerRow}, total=${bm.packed.length} bytes`);

    // é‡è¦ï¼šé€™è£¡åªæ˜¯æŠŠã€Œæ‰“åŒ…å¾Œçš„ä½åœ–è³‡æ–™ã€ç•¶ raw bytes ä¸²æµé€å‡ºã€‚
    // å¾ˆå¤š P2HD éœ€è¦ "0x02...0x03" çš„åˆ—å°å‘½ä»¤å°åŒ…æ‰èƒ½çœŸçš„é–‹å§‹å°ã€‚
    // ä½ å…ˆç”¨é€™ä¸€æ­¥æ¸¬è©¦ BLE å¤§é‡å¯«å…¥æ˜¯å¦ç©©å®šï¼Œä¸¦æŠŠ notify/log è²¼å›ä¾†ï¼Œæˆ‘å†å¹«ä½ è£œã€Œæ­£ç¢ºå°åŒ…å”å®šã€ã€‚

    const CHUNK = 180; // æ–°æ‰‹å…ˆä¿å®ˆï¼ˆé¿å… MTU é™åˆ¶ï¼‰ã€‚ç©©äº†å¯èª¿ 200/240/244
    const chunks = chunkArray(bm.packed, CHUNK);

    log(`Sending chunks: ${chunks.length}, chunkSize=${CHUNK} ...`);
    alert('é–‹å§‹é€å‡ºä½åœ–è³‡æ–™ï¼ˆrawï¼‰ã€‚è‹¥æ²’å°å‡ºï¼Œå±¬æ­£å¸¸ï¼šæ¥ä¸‹ä¾†éœ€è¦å°æ¥ P2HD åˆ—å°å°åŒ…å”å®šã€‚');

    await writeChunks(chunks, 10);

    log('âœ… Raw bitmap bytes sent.');
    alert('å·²é€å®Œä½åœ–è³‡æ–™ã€‚è«‹çœ‹ log / notify æ˜¯å¦æœ‰å›æ‡‰ã€‚');

  } catch (e) {
    log('âŒ SEND error:', e.message);
    alert('é€å‡ºå¤±æ•—ï¼š' + e.message);
  }
});
</script>
</body>
</html>
